<h1 align='left'>Perlbal Service parameters</h1>Set via the command:<pre>SET &lt;service-name&gt;.&lt;param&gt; = &lt;value&gt;</pre>Note on types:  'bool' values can be set using one of 1, true, yes, on, 0, false, off, or no.  'size' values are in integer bytes, or an integer followed by 'b', 'k', or 'm' (case-insensitive) for bytes, KiB, or MiB.<h2>For all services:</h2><table border='2' cellspacing='1' cellpadding='4'>
<tr align='left'><th>Param</th><th>type</th><th>Default</th><th>Description</th></tr>
<tr><td>listen</td><td></td><td></td><td>The ip:port to listen on.  For a service to work, you must either make it listen, or make another selector service map to a non-listening service.</td></tr>
<tr><td>persist_client</td><td>bool</td><td>false</td><td>Whether to enable HTTP keep-alives to the end user.</td></tr>
<tr><td>role</td><td></td><td></td><td>What type of service.  One of 'reverse_proxy' for a service that load balances to a pool of backend webserver nodes, 'web_server' for a typical webserver', 'management' for a Perlbal management interface (speaks both command-line or HTTP, auto-detected), or 'selector', for a virtual service that maps onto other services.</td></tr>
</table>
<h2>Only for 'reverse_proxy' services:</h2><table border='2' cellspacing='1' cellpadding='4'>
<tr align='left'><th>Param</th><th>type</th><th>Default</th><th>Description</th></tr>
<tr><td>always_trusted</td><td>bool</td><td>false</td><td>Whether to trust all incoming requests' X-Forwarded-For and related headers.  Set to true only if you know that all incoming requests from your own proxy servers that clean/set those headers.</td></tr>
<tr><td>backend_persist_cache</td><td>int</td><td>2</td><td>The number of backend connections to keep alive on reserve while there are no clients.</td></tr>
<tr><td>buffer_backend_connect</td><td>size</td><td>0</td><td>How much content-body (POST/PUT/etc) data we read from a client before we start sending it to a backend web node.</td></tr>
<tr><td>buffer_size</td><td>size</td><td>256k</td><td>How much we'll ahead of a client we'll get while copying from a backend to a client.  If a client gets behind this much, we stop reading from the backend for a bit.</td></tr>
<tr><td>buffer_size_reproxy_url</td><td>size</td><td>50k</td><td>How much we'll get ahead of a client we'll get while copying from a reproxied URL to a client.  If a client gets behind this much, we stop reading from the reproxied URL for a bit.  The default is lower than the regular buffer_size (50k instead of 256k) because it's assumed that you're only reproxying to large files on event-based webservers, which are less sensitive to many open connections, whereas the 256k buffer size is good for keeping heavy process-based free of slow clients.</td></tr>
<tr><td>connect_ahead</td><td>int</td><td>0</td><td>How many extra backend connections we keep alive in addition to the current ones, in anticipation of new client connections.</td></tr>
<tr><td>high_priority_cookie</td><td></td><td></td><td>The cookie name to inspect to determine if the client goes onto the high-priority queue.</td></tr>
<tr><td>high_priority_cookie_contents</td><td></td><td></td><td>A string that the high_priority_cookie must contain to go onto the high-priority queue.</td></tr>
<tr><td>max_backend_uses</td><td></td><td>0</td><td>The max number of requests to be made on a single persistent backend connection before releasing the connection.  The default value of 0 means no limit, and the connection will only be discarded once the backend asks it to be, or when Perlbal is sufficiently idle.</td></tr>
<tr><td>persist_backend</td><td>bool</td><td>false</td><td>Whether to enable HTTP keep-alives to the backend webnodes.  (Off by default, but highly recommended if Perlbal will be the only client to your backends.  If not, beware that Perlbal will hog the connections, starving other clients.)</td></tr>
<tr><td>pool</td><td></td><td></td><td>Name of previously-created pool object containing the backend nodes that this reverse proxy sends requests to.</td></tr>
<tr><td>queue_relief_chance</td><td></td><td>0</td><td></td></tr>
<tr><td>queue_relief_size</td><td>int</td><td>0</td><td></td></tr>
<tr><td>trusted_upstream_proxies</td><td></td><td></td><td>A Net::Netmask filter (e.g. 10.0.0.0/24, see Net::Netmask) that determines whether upstream clients are trusted or not, where trusted means their X-Forwarded-For/etc headers are not munged.</td></tr>
<tr><td>verify_backend</td><td>bool</td><td>false</td><td>Whether Perlbal should send a quick OPTIONS request to the backends before sending an actual client request to them.  If your backend is Apache or some other process-based webserver, this is HIGHLY recommended.  All too often a loaded backend box will reply to new TCP connections, but it's the kernel's TCP stack Perlbal is talking to, not an actual Apache process yet.  Using this option reduces end-user latency a ton on loaded sites.</td></tr>
</table>
<h2>Only for 'web_server' services:</h2><table border='2' cellspacing='1' cellpadding='4'>
<tr align='left'><th>Param</th><th>type</th><th>Default</th><th>Description</th></tr>
<tr><td>dirindexing</td><td>bool</td><td>false</td><td>Show directory indexes when an HTTP request is for a directory.  Warning:  this is not an async operation, so will slow down Perlbal on heavily loaded sites.</td></tr>
<tr><td>docroot</td><td></td><td></td><td>Directory root for web server.</td></tr>
<tr><td>enable_delete</td><td>bool</td><td>false</td><td>Enable HTTP DELETE requests.</td></tr>
<tr><td>enable_put</td><td>bool</td><td>false</td><td>Enable HTTP PUT requests.</td></tr>
<tr><td>index_files</td><td></td><td>index.html</td><td>Comma-seperated list of filenames to load when a user visits a directory URL, listed in order of preference.</td></tr>
<tr><td>max_put_size</td><td>size</td><td>0</td><td>The maximum content-length that will be accepted for a PUT request, if enable_put is on.  Default value of 0 means no limit.</td></tr>
<tr><td>min_put_directory</td><td>int</td><td>0</td><td>If PUT requests are enabled, require this many levels of directories to already exist.  If not, fail.</td></tr>
</table>
